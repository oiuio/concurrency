[toc]

# 并发入门

## 导读

* 并发：同时拥有两个或多个线程，如果程序再单核处理器上运行，多个线程将交替地换入或者换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行
  
* 高并发：高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能供**同时并行处理**很多请求

* 区别：
  * 并发：多个线程操作相同的资源，保证线程安全，合理使用资源
  * 高并发：服务能同时处理很多请求，提高程序性能

## 并发编程的基础

### 缓存：
* 解决：缓解CPU与内存速度不匹配
* 意义：
  * 时间局部性：
  * 空间局部性：

### 多级缓存 - 缓存一致性（MESI协议）
* 用于保证多个CPU cache之间缓存共享数据的一致
* M：被修改 E：独享 S：共享 I：无效
* 四种操作
  * local read
  * local write
  * remote read
  * remote write

### 多级缓存 - 乱序执行优化
* 处理器为提高运算速度而做出违背代码原有顺序的优化

### Java内存模型（Java Memory Model，JMM）
* 同步八种操作：锁定、解锁、读取、载入、使用、赋值、存储、写入
  * lock（锁定）：作用于主内存的变量，把一个变量表示为一条线程独占状态
  * unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
  * read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以遍随后的load动作使用
  * load（载入）：作用于工作内存的变量，他把read操作从主内存得到的变量值放入工作内存的变量副本中
  * use（使用）：作用于工作内存的变量，把工作内存的一个变量值传递给执行引擎
  * assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量
  * store（存储）：作用于工作内存的变量，把工作内存中的一个变量值传送到主内存中，以便随后的wirte的操作
  * write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中
* 操作的基本规则：
  * 

### 并发的优势于劣势


## 项目准备

### 并发模拟
* Postman：Http请求模拟工具
* Apache Bench（AB）：Apache附带的工具，测试网站性能
* JMeter：Apache组织开发的压力测试工具
* 代码：Semaphore，CountDownLatch等

## 线程安全性
* 定义：当多个线程访问某个类时，不管运行时环境采用**何种调度方式**或者这些进程将如何交替执行，并且在主调代码中**不需要任何额外的同步或协同**，这个类都能表现出正确的行为，那么就称这个类是线程安全的
* 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作
* 可见性：一个线程在主内存的修改可以及时被其他线程观察到
* 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，观察结果一般杂乱无序

### 原子性 - Atomic包
* AtomicXXX：CAS、Unsafe.compareAndSwapInt
* AtomiceLong、LongAdder
* AtomicReference、AtomicReferenceFieldUpdater
* AtomicStampReference：CAS的ABA问题

### 原子性 - 锁
* synchronized：依赖JVM，作用对象的作用范围内
* Lock：依赖特殊的CPU指令，代码实现，ReentrantLock

#### 原子性 - synchronized
* 修饰代码块：大括号括起来的代码，作用于调用的对象
* 修饰方法：整个方法，作用于调用的对象  子类继承父类，方法没有synchronized，不属于方法声明一部分
* 修饰静态方法：整个静态方法，作用于所有对象
* 修饰类：括号括起来的部分，作用于所有对象

#### 原子性 - 对比
* synchronized：不可中断锁，适合竞争不激烈，可读性好
* Lock：可中断锁，多样化同步，竞争激烈时能维持常态
* Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值

### 可见性
* 导致共享变量在线程间不可见的原因
  * 线程交叉执行
  * 重排序结合线程交叉执行
  * 共享变量更新后的值没有在工作内存与主存之间及时更新

#### 可见性 - synchronized
* 线程解锁前，必须把共享变量的最新值刷新到主内存
* 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁是同一把锁）

